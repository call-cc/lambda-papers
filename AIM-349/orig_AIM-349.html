<!-- TODO: code validation -->
<!-- TODO: grammar check -->
<!-- TODO: references -->
<!-- TODO: HTML5-ify -->

<!DOCTYPE html>
<html lang='en'>
    <head>
        <meta charset='utf-8'>
        <title>Scheme: An interpreter for extended lambda calculus</title>
    </head>

    <body>
	<h1>Scheme: An interpreter for extended lambda calculus</h1>

        <div id='abstract'>
            <h2>Abstract</h2>

            <p>
            Inspired by ACTORS [Greif and Hewitt] [Smith and Hewitt], we have
            implemented an interpreter for a LISP-like language, SCHEME, based
            on the lambda calculus [Church], but extended for side effects,
            multiprocessing, and process synchronization. The purpose of this
            implementation is tutorial. We wish to:
            </p>

            <ol>
                <li>alleviate the confusion caused by Micro-PLANNER, CONNIVER,
                etc. by clarifying the embedding of non-recursive control
                structures in a recursive host language like LISP.
                <li>explain how to use these control structures, independent of
                such issues as pattern matching and data base manipulation.
                <li>have a simple concrete experimental domain for certain
                issues of programming semantics and style.
            </ol>

            <p>
            This paper is organized into sections. The first section is a short
            "reference manual" containing specifications for all the unusual
            features of SCHEME. Next, we present a sequence of programming
            examples which illustrate various programming styles, and how to
            use them. This will raise certain issues of semantics which we will
            try to clarify with lambda calculus in the third section. In the
            fourth section we will give a general discussion of the issues
            facing an implementor of an interpreter for a language based on
            lambda calculus. Finally, we present a completely annotated
            interpreter for SCHEME, written in MacLISP [Moon], to acquaint
            programmers with the tricks of the trade of implementing
            non-recursive control structures in a recursive language like LISP.
            </p>
        </div>

        <div>
            <p>
            This report describes research done at the Artificial Intelligence
            Laboratory of the Massachusetts Institute of Technology. Support
            for the laboratory's artificial intelligence research is provided
            in part by the Advanced Research Projects Agency of the Department
            of Defense under Office of Naval Research contract
            N00014-75-C-0643.
            </p>
        </div>

        <div>
            <h2>Section 1: The SCHEME Reference Manual</h2>

            <p>
            SCHEME is essentially a full-funarg LISP. <code>LAMBDA</code>
            expressions need not be <code>QUOTE</code>d,
            <code>FUNCTION</code>ed, or <code>*FUNCTION</code>ed when passed as
            arguments or returned as values; they will evaluate to closures of
            themselves.
            </p>

            <p>
            All LISP functions (i.e., <code>EXPR</code>s, <code>SUBR</code>s,
            and <code>LSUBR</code>s, but <em>not</em> <code>FEXPR</code>s,
            <code>FSUBR</code>s, or <code>MACRO</code>s) are primitive operators in
            SCHEME, and have the same meaning as they have in LISP. Like
            <code>LAMBDA</code> expressions, primitive operators and numbers
            are self-evaluating (they evaluate to trivial closures of
            themselves).
            </p>

            <p>
            There are a number of special primitives known as
            <code>AINT</code>s which are to SCHEME as <code>FSUBR</code>s are to
            LISP. We will enumerate them here.
            </p>

            <h3><code>IF</code></h3>
	    <p>
            This is the primitive conditional operator. It takes three
            arguments. If the first evaluates to non-<code>NIL</code>, it
            evaluates the second expression, and otherwise the third.
	    </p>

            <h3><code>QUOTE</code></h3>
            <p>
            As in LISP, this quotes the argument form so that it will be passed
            verbatim as data. The abbreviation "<code>'FOO</code>" may be used
            instead of "<code>(QUOTE FOO)</code>".
            </p>

            <h3><code>DEFINE</code></h3>
            <p>
            This is analogous to the MacLISP <code>DEFUN</code> primitive (but
            note that the <code>LAMBDA</code> must appear explicitly!). It is
            used for defining a function in the "global environment"
            permanently, as opposed to <code>LABELS</code> (see below), which
            is used for temporary definitions in a local environment.
            <code>DEFINE</code> takes a name and a lambda expression; it closes
            the lambda expression in the global environment and stores the
            closure in the LISP value cell of the name (which is a LISP atom).
            </p>

            <h3><code>LABELS</code></h3>
            <p>
            We have decided not to use the traditional <code>LABEL</code>
            primitive in this interpreter because it is difficult to define
            several mutually recursive functions using only <code>LABEL</code>.
            The solution, which Hewitt [Smith and Hewitt] also uses, is to
            adopt an ALGOLesque block syntax:
            </p>

            <pre><code>
    (LABELS &lt;function definition list&gt; &lt;expression&gt;)
</code></pre>

            <p>
            This has the effect of evaluating the expression in an environment
            where all the functions are defined as specified by the definition
            list. Furthermore, the functions are themselves closed in that
            environment, and not in the outer environment; this allows the
            functions to call themselves <em>and each other</em> recursively.
            For example, consider a function which counts all the atoms in a
            list structure recursively to all levels, but which doesn't count
            the <code>NIL</code>s which terminate the lists (but
            <code>NIL</code>s in the <code>CAR</code> of some list count). In
            order to perform this we use two mutually recursive functions, one
            to count the car and one to count the cdr, as follows:
            </p>

            <pre><code>
    (DEFINE COUNT
        (LAMBDA (L)
            (LABELS ((COUNTCAR
                      (LAMBDA (L)
                          (IF (ATOM L) 1
                              (+ (COUNTCAR (CAR L))
                                 (COUNTCAR (CDR L))))))
                     (COUNTCDR
                      (LAMBDA (L)
                          (IF (ATOM L)
                              (IF (NULL L) 0 1)
                              (+ (COUNTCAR (CAR L))
                                 (COUNTCDR (CDR L)))))))
               (COUNTCDR L))))             ; Note: COUNTCDR is defined here.
</code></pre>

            <h3><code>ASET</code></h3>
            <p>
            This is the side effect primitive. It is analogous to the LISP function
            <code>SET</code>. For example, to define a <em>cell</em> [Smith and
            Hewitt], we may use <code>ASET</code> as follows:
            </p>

            <pre><code>
    (DEFINE CONS-CELL
        (LAMBDA (CONTENTS)
            (LABELS ((THE-CELL
                      (LAMBDA (MSG)
                          (IF (EQ MSG 'CONTENTS?) CONTENTS
                              (IF (EQ MSG 'CELL?) 'YES
                                  (IF (EQ (CAR MSG) '&lt;-)
                                      (BLOCK (ASET 'CONTENTS (CADR MSG))
                                             THE-CELL)
                                      (ERROR '|UNRECOGNIZED MESSAGE - CELL|
                                              MSG
                                           'WRNG-TYPE-ARG)))))))
                   THE-CELL)))
</code></pre>

            <p>
            Those of you who may complain about the lack of <code>ASETQ</code> are
            invited to write <code>(ASET' foo bar)</code> instead of
            <code>(ASET 'foo bar)</code>
            </p>

            <h3><code>EVALUATE</code></h3>
            <p>
            This is similar to the LISP function <code>EVAL</code>. It evaluates its
            argument, and then evaluates the resulting s-expression as SCHEME code.
            </p>

            <h3><code>CATCH</code></h3>
            <p>
            This is the "escape operator" which gives the user a handle on the
            control structure of the interpreter. The expression:
            </p>

            <pre><code>
    (CATCH &lt;identifier&gt; &lt;expression&gt;)
</code></pre>

            <p>
            evaluates <code>&lt;expression&gt;</code> in an environment where
            <code>&lt;identifier&gt;</code> is bound to a continuation which is
            "just about to return from the <code>CATCH</code>"; that is, if the
            continuation is called as a function of one argument, then control
            proceeds as if the <code>CATCH</code> expression had returned with the
            supplied (evaluated) argument as its value. For example, consider the
            following obscure definition of <code>SQRT</code> (Sussman's favorite
            style/Steele's least favorite):
            </p>

            <pre><code>
    (DEFINE SQRT
        (LAMBDA (X EPSILON)
            ((LAMBDA (ANS LOOPTAG)
                 (CATCH RETURNTAG
                        (PROGN
                         (ASET 'LOOPTAG (CATCH M M))        ;CREATE PROG TAG
                         (IF (&lt; (ABS (-$ (*$ ANS ANS) X)) EPSILON)
                             (RETURNTAG ANS)                ;RETURN
                             NIL)                           ;JFCL
                         (ASET 'ANS (//$ (+$ (//$ X ANS) ANS) 2.0))
                         (LOOPTAG LOOPTAG))))               ;GOTO
             1.0
             NIL)))
</code></pre>

            <p>
            Anyone who doesn't understand how this manages to work probably
            should not attempt to use <code>CATCH</code>.
            </p>

            <p>
            As another example, we can define a <code>THROW</code> function, which
            may then be used with <code>CATCH</code> much as they are in LISP:
            </p>

            <pre><code>
    (DEFINE THROW (LAMBDA (TAG RESULT) (TAG RESULT)))
</code></pre>

            <h3><code>CREATE!PROCESS</code></h3>
            <p>
            This is the process generator for multiprocessing. It takes one
            argument, an expression to be evaluated in the current environment as a
            separate parallel process. If the expression ever returns a value, the
            process automatically terminates. The value of
            <code>CREATE!PROCESS</code> is a process id for the newly generated
            process. Note that the newly created process will not actually run until
            it is explicitly started.
            </p>

            <h3><code>START!PROCESS</code></h3>
            <p>
            This takes one argument, a process id, and starts up that process. It
            then runs.
            </p>

            <h3><code>STOP!PROCESS</code></h3>
            <p>
            This also takes a process id, but stops the process. The stopped process
            may be continued from where it was stopped by using
            <code>START!PROCESS</code> again on it. The magic global variable
            <code>**PROCESS**</code> always contains the process id of the currently
            running process; thus a process can stop itself by doing
            <code>(STOP!PROCESS **PROCESS**)</code>. A stopped process is garbage
            collected if no live process has a pointer to its process id.
            </p>

            <h3><code>EVALUATE!UNINTERRUPTIBLY</code></h3>
            <p>
            This is the synchronization primitive. It evaluates an expression
            uninterruptibly; i.e. no other process may run until the expression has
            returned a value. Note that if a funarg is returned from the scope of an
            <code>EVALUATE!UNINTERRUPTIBLY</code>, then that funarg will be
            uninterruptible when it is applied; that is, the uninterruptibility
            property follow the rules of variable scoping. For example, consider
            the following function:
            </p>

            <pre><code>
    (DEFINE SEMGEN
        (LAMBDA (SEMVAL)
            (LIST (LAMBDA ()
                      (EVALUATE!UNINTERRUPTIBLY
                          (ASET' SEMVAL (+ SEMVAL 1))))
                  (LABELS (P (LAMBDA ()
                                 (EVALUATE!UNINTERRUPTIBLY
                                     (IF (PLUSP SEMVAL)
                                         (ASET' SEMVAL (- SEMVAL 1))
                                         (P)))))
                         P))))
</code></pre>

            <p>
            This returns a pair of functions which are V and P operations on a newly
            created semaphore. The argument to <code>SEMGEN</code> is the initial
            value for the semaphore. Note that P busy-waits by iterating if
            necessary; because <code>EVALUATE!UNINTERRUPTIBLY</code> uses
            variable-scoping rules, other processes have a chance to get in at the
            beginning of each iteration. This busy-wait can be made much more
            efficient by replacing the expression <code>(P)</code> in the definition
            of <code>P</code> with
            </p>

            <pre><code>
    ((LAMBDA (ME)
             (BLOCK (START!PROCESS (CREATE!PROCESS '(START!PROCESS ME)))
                    (STOP!PROCESS ME)
                    (P)))
     **PROCESS**)
</code></pre>

            <p>
            Let's see you figure this one out! Note that a <code>STOP!PROCESS</code>
            within an <code>EVALUATE!UNINTERRUPTIBLY</code> forces the process to be
            swapped out even if it is the current one, and so other processes get to
            run; but as soon as it gets swapped in again, others are locked out as
            before.
            </p>

            <p>
            Besides the <code>AINT</code>s, SCHEME has class of primitives known as
            <code>AMACRO</code>s. These are similar to MacLISP <code>MACRO</code>s, in
            that they are expanded into equivalent code before being executed. Some
            <code>AMACRO</code>s supplied with the SCHEME interpreter:
            </p>

            <h3><code>COND</code></h3>
            <p>
            This is like the MacLISP <code>COND</code> statement, except that
            singleton clauses (where the result of the predicate is the returned
            value) are not allowed.
            </p>

            <h3><code>AND</code>, <code>OR</code></h3>
            <p>
            These are also as in MacLISP.
            </p>

            <h3><code>BLOCK</code></h3>
            <p>
            This is like the MacLISP <code>PROGN</code>, but arranges to evaluate
            its last argument without an extra net control frame (explained later),
            so that the last argument may involved in an iteration. Note that in
            SCHEME, unlike MacLISP, the body of a <code>LAMBDA</code> expression is
            <em>not</em> an implicit <code>PROGN</code>.
            </p>

            <h3><code>DO</code></h3>
            <p>
            This is like that MacLISP "new-style" <code>DO</code>; old-style
            <code>DO</code> is not supported.
            </p>

            <h3><code>AMAPCAR</code>, <code>AMAPLIST</code></h3>
            <p>
            These are like <code>MAPCAR</code> and <code>MAPLIST</code>, but they
            expect a SCHEME lambda closure for the first argument.
            </p>

            <p>
            To use SCHEME, simply incant at DDT (MIT-AI):
            </p>

            <pre><code>
    :LISP LIBLSP;SCHEME
</code></pre>

            <p>
            which will load up the current version of SCHEME, which will announce
            itself and give a prompt. If you want to escape to LISP, merely hit
            <code>^G</code>. To restart SCHEME, type <code>(SCHEME)</code>.
            Sometimes one does need to use a LISP <code>FSUBR</code> such as
            <code>UREAD</code>; this may be accomplished by typing, for example,
            </p>

            <pre><code>
    (EVAL' (UREAD FOO BAR DSK LOSER))
</code></pre>

            <p>
            After doing this, typing <code>^Q</code> will, of course, cause SCHEME
            to read from the file.
            </p>

            <p>
            This concludes the SCHEME Reference Manual.
            </p>

        </div>

        <div>
            <h2>Section 2: Some SCHEME Programming Examples</h2>

            <h3>Traditional Recursion</h3>
            <p>
            Here is the good old familiar recursive definition of factorial,
            written in SCHEME.
            </p>

            <pre><code>
    (DEFINE FACT
       (LAMBDA (N) (IF (= N 0) 1
                       (* N (FACT (- N 1))))))
</code></pre>

            <h3>What About Iteration?</h3>
            <p>
            There are many other ways to compute factorial. One important way is
            through the use of <em>iteration</em>. Consider the following
            definition of <code>FACT</code>. Although it appears to be
            recursive, since it "calls itself", it captures the essence of our
            intuitive notion of iteration, because execution of this program
            will not produce internal structures (e.g. stacks or variable
            bindings) which increase in size with the number of iteration steps.
            This surprising fact will be explained in two ways.
            </p>

            <ol>
                <li>We will consider programming styles in terms of substitution
                semantics of the lambda calculus (Section 3).
                <li>We will show how the SCHEME interpreter is implemented
                (Sections 4,5).
            </ol>

            <pre><code>
    (DEFINE FACT
       (LAMBDA (N)
           (LABELS ((FACT1 (LAMBDA (M ANS)
                               (IF (= M 0) ANS
                                       (FACT1 (- M 1)
                                              (* M ANS))))))
                    (FACT1 N))))
</code></pre>

            <p>
            A common iterative construct is the <code>DO</code> loop. The most
            general form we have seen in any programming language is the MacLISP
            <code>DO</code> [Moon]. It permits the simultaneous initialization
            of any number of control variables and the simultaneous stepping of
            these variables by arbitrary functions at each iteration step. The
            loop is terminated by an arbitrary predicate, and an arbitrary value
            may be returned. The <code>DO</code> loop may have a body, a series
            of expressions executed for effect on each iteration.
            </p>

            <p>
            The general form of a MacLISP <code>DO</code> is:
            </p>

            <pre><code>
    (DO ((&lt;var1&gt; &lt;init1&gt; &lt;step1&gt;)
         (&lt;var2&gt; &lt;init2&gt; &lt;step2&gt;)
         . . .
         (&lt;varn&gt; &lt;initn&gt; &lt;stepn&gt;))
        (&lt;pred&gt; &lt;value&gt;)
        &lt;body&gt;)

</code></pre>

            <p>
            The semantics of this are that the variables are bound and
            initialized to the values of the &lt;initi&gt; expressions, which
            must all be evaluated in the environment outside the
            <code>DO</code>; then the predicate &lt;pred&gt; is evaluated in the
            new environment, and if <code>TRUE</code>, the &lt;value&gt; is
            evaluated and returned. Otherwise the body is evaluated, then each
            of the steppers &lt;stepi&gt; is evaluated in the current
            environment, all the variables made to have the results as their
            values, and the predicate evaluated again, and so on.
            </p>

            <p>
            For example, the following MacLISP function:
            </p>

            <pre><code>
    (DEFUN REV (L)
           (DO ((L1 L (CDR L1))
                (ANS NIL (CONS (CAR L1) ANS)))
               ((NULL L1) ANS)))
</code></pre>

            <p>
            computes the reverse of a list. In SCHEME, we could write the same
            function, in the same iterative style, as follows:
            </p>

            <pre><code>
    (DEFINE REV
        (LAMBDA (L)
            (LABELS ((DOLOOP (LAMBDA (L1 ANS)
                                 (IF (NULL L1) ANS
                                     (DOLOOP (CDR L1)
                                             (CONS (CAR L1) ANS))))))
                    (DOLOOP L NIL))))
</code></pre>

            <p>
            From this we can infer a general way to express iterations in SCHEME
            in a manner isomorphic to the MacLISP <code>DO</code>:
            </p>

            <pre><code>
    (LABELS ((DOLOOP
              (LAMBDA (&lt;dummy&gt; &lt;var1&gt; &lt;var2&gt; ... &lt;varn&gt;)
                  (IF &lt;pred&gt; &lt;value&gt;
                      (DOLOOP &lt;body&gt; &lt;step1&gt; &lt;step2&gt; ... &lt;stepn&gt;)))))
            (DOLOOP NIL &lt;init1&gt; &lt;init2&gt; ... &lt;initn&gt;))
</pre></code>

            <p>
            This is in fact what the supplied <code>DO</code>
            <code>AMACRO</code> expands into. Note that there are no side
            effects in the steppings of the iteration variables.
            </p>

            <h3>Another Way To Do Recursion</h3>
            <p>
            Now consider the following alternative definition of
            <code>FACT</code>. It has an extra argument, the
            <em>continuation</em> [Reynolds], which is a function to call with
            the answer, when we have it, rather than return a value; that is,
            rather than ultimately reducing to the desired value, it reduces to
            a combination which is the application of the continuation to the
            desired value.
            </p>

            <pre><code>
    (DEFINE FACT
        (LAMBDA (N C)
           (IF (= N 0) (C 1)
               (FACT (- N 1)
                     (LAMBDA (A) (C (* N A)))))))
</code></pre>

            <p>
            Note that we can call this like an ordinary function if we supply
            <code>(LAMBDA (X) X)</code> as the second argument. For example,
            <code>(FACT 3 (LAMBDA (X) X))</code> returns 6.
            </p>

            <h3>Apparently "Hairy" Control Structure</h3>
            <p>
            A classic problem difficult to solve in most programming languages,
            including standard (stack-oriented) LISP, is the <em>samefringe</em>
            problem [Smith and Hewitt]. The problem is to determine whether the
            fringes of two trees are the same, even if the internal structures
            of the trees are not. This problem is easy to solve if one merely
            computes the fringe of each tree separately as a list, and then
            compares the two lists. We would like to solve the problem so that
            the fringes are generated and compared incrementally. This is
            important if the fringes of the trees are very large, but differ,
            say, in the first position.
            </p>

            <p>
            Consider the following obscure solution to <em>samefringe</em>,
            which is in fact isomorphic to the one written by Shrobe and
            presented by Smith and Hewitt. Note that SCHEME does not have the
            packagers of PLASMA, and so we were forced to use continuations;
            rather than using packages and a <em>next</em> operator, we pass a
            fringe a continuation (called a "getter") which will get the next
            and the rest of the fringe as its two arguments.
            </p>

            <pre><code>
    (DEFINE FRINGE
       (LAMBDA (TREE)
           (LABELS ((FRINGEN
                     (LAMBDA (NODE ALT)
                         (LAMBDA (GETTER)
                             (IF (ATOM NODE)
                                 (GETTER NODE ALT)
                                 ((FRINGEN (CAR NODE)
                                           (LAMBDA (GETTER1)
                                               ((FRINGEN (CDR NODE)
                                                         ALT)
                                                GETTER1)))
                                   GETTER))))))
                    (FRINGEN TREE
                             (LAMBDA (GETTER)
                                 (GETTER '(EXHAUSTED) NIL))))))

    (DEFINE SAMEFRINGE
       (LAMBDA (TREE1 TREE2)
           (LABELS ((SAME
                     (LAMBDA (S1 S2)
                         (S1 (LAMBDA (X1 R1)
                                 (S2 (LAMBDA (X2 R2)
                                         (IF (EQUAL X1 X2)
                                             (IF (EQUAL X1 '(EXHAUSTED))
                                                 T
                                                 (SAME R1 R2))
                                            NIL))))))))
                   (SAME (FRINGE TREE1)
                         (FRINGE TREE2)))))
</code></pre>

            <p>
            Now let us consider an alternative solution to the
            <em>samefringe</em> problem. We believe that this solution is
            clearer for two reasons:
            </p>

            <ol>
                <li>the implementation of <code>SAMEFRINGE</code> is more
                clearly iterative;
                <li>rather than returning an object which will return both the
                <em>first</em> and the <em>rest</em> of a fringe to a given
                continuation, <code>FRINGE</code> returns an object which will
                deliver up a component in response to a request for that
                component.
            </ol>

            <code><pre>
    (DEFINE FRINGE
        (LAMBDA (TREE)
            (LABELS ((FRINGE1
                      (LAMBDA (NODE ALT)
                         (IF (ATOM NODE)
                             (LAMBDA (MSG)
                                 (IF (EQ MSG 'FIRST) NODE
                                     (IF (EQ MSG 'NEXT) (ALT) (ERROR))))
                             (FRINGE1 (CAR NODE)
                                      (LAMBDA () (FRINGE1 (CDR NODE) ALT)))))))
                    (FRINGE1 TREE
                             (LAMBDA ()
                                 (LAMBDA (MSG) (IF (EQ MSG 'FIRST) '*EOF* (ERROR))))))))

    (DEFINE SAMEFRINGE
        (LAMBDA (T1 T2)
            (DO ((C1 (FRINGE T1) (C1 'NEXT))
                 (C2 (FRINGE T2) (C2 'NEXT)))
                ((OR (NOT (EQ (C1 'FIRST) (C2 'FIRST)))
                     (EQ (C1 'FIRST) '*EOF*)
                     (EQ (C2 'FIRST) '*EOF*))
                 (EQ (C1 'FIRST) (C2 'FIRST))))))
</code></pre>

            <p>
            A much simpler and more probable problem is that of building a
            pattern matcher with backtracking for segment matches. The matcher
            presented below is intended for matching single-level list structure
            patterns against lists of atoms. A pattern is a list containing
            three types of elements:
            </p>

            <ol>
                <li>constant atoms, which match themselves only.
                <li><code>(TVH x)</code>, which matches any single element in
                the expression consistently. We may abbreviate this as ?x by
                means of a LISP reader macro character.
                <li><code>(TVH* x)</code>, which matches any segment of zero or
                more elements in the expression consistently. We may abbreviate
                this as !x.
            </ol>

            <p>
            The matcher returns either <code>NIL</code>, meaning no match is
            possible, or a list of two items, an alist specifying the bindings
            of the match variables, and a continuation to call, if you don't
            like this particular set of bindings, which will attempt to find
            another match. Thus, for example, the invocation
            </p>

            <pre><code>
    (MATCH '(A !B ?C ?C !B !E)
           '(A X Y Q Q X Y Z Z X Y Q Q X Y R))
</code></pre>

            <p>
            would return the result
            </p>

            <pre><code>
    (((E (Z Z X Y Q Q X Y R))
      (C Q)
      (B X Y))
     &lt;continuation1&gt;)
</code></pre>

            <p>
            where calling <code>&lt;continuation1&gt;</code> as a function of no
            arguments would produce the result
            </p>

            <pre><code>
    (((E (R))
      (C Z)
      (B (X Y Q Q X Y)))
      &lt;continuation2&gt;)
</code></pre>

            <p>
            where calling <code>&lt;continuation2&gt;</code> would produce
            <code>NIL</code>.
            </p>

            <p>
            The <code>MATCH</code> function makes use of two auxiliary functions
            called <code>NFIRST</code> and <code>NREST</code>. The former
            returns the list of the first n elements of a given list, while the
            latter returns the tail of the given list after the first n
            elements.
            </p>

            <pre><code>
    (define nfirst
       (lambda (e n)
           (if (= n 0) nil
               (cons (car e) (nfirst (cdr e) (- n 1))))))

    (define nrest
       (lambda (e n)
           (if (= n 0) e
               (nrest (cdr e) (- n 1)))))
</code></pre>

            <p>
            The main <code>MATCH</code> function also uses a subfunction called
            <code>MATCH1</code> which takes four arguments; the tail of the
            pattern yet to be matched; the tail of the expression yet to be
            matched; the alist of match bindings made so far; and a continuation
            to call if the match fails at this point. A subfunction of
            <code>MATCH</code>, called <code>MATCH*</code>, handles the matching
            of segments of the expression against <code>TVH*</code> match
            variables. It is in the matching segments that the potential need
            for backtracking enters, for segments of various lengths may have to
            be tried. After <code>MATCH*</code> matches a segment, it calls
            <code>MATCH1</code> to continue the match, giving it a failure
            continuation which will back up and try to match a longer segment if
            possible. A failure can occur if a constant fails a match, or if one
            or the other of pattern and expression runs out before the other one
            does.
            </p>

            <pre><code>
    (DEFINE MATCH
       (LAMBDA (PATTERN EXPRESSION)
           (LABELS ((MATCH1
               (LAMBDA (P E ALIST LOSE)
                   (IF (NULL P) (IF (NULL E) (LIST ALIST LOSE) (LOSE))
                       (IF (ATOM (CAR P))
                           (IF (NULL E) (LOSE)
                               (IF (EQ (CAR E) (CAR P))
                                   (MATCH1 (CDR P) (CDR E) ALIST LOSE)
                                   (LOSE)))
                           (IF (EQ (CAAR P) 'THV)
                               (IF (NULL E) (LOSE)
                                   ((LAMBDA (V)
                                        (IF V (IF (EQ (CAR E) (CADR V))
                                                  (MATCH1 (CDR P) (CDR E) ALIST LOSE)
                                                  (LOSE))
                                            (MATCH1 (CDR P) (CDR E)
                                                    (CONS (LIST (CADAR P) (CAR E)) ALIST)
                                                    LOSE)))
                                    (ASSQ (CADAR P) ALIST)))
                           (IF (EQ (CAAR P) 'THV*)
                               ((LAMBDA (V)
                                    (IF V
                                        (IF (&LT; (LENGTH E) (LENGTH (CADR V))) (LOSE)
                                            (IF (EQUAL (NFIRST E (LENGTH (CADR V)))
                                                       (CADR V))
                                                (MATCH1 (CDR P)
                                                        (NREST E (LENGTH (CADR V)))
                                                        ALIST
                                                        LOSE)
                                                (LOSE)))
                                        (LABELS ((MATCH*
                                            (LAMBDA (N)
                                                (IF (&GT; N (LENGTH E)) (LOSE)
                                                    (MATCH1 (CDR P) (NREST E N)
                                                            (CONS (LIST (CADAR P)
                                                                        (NFIRST E N))
                                                                  ALIST)
                                                            (LAMBDA ()
                                                                (MATCH* (+ N 1))))))))
                                                (MATCH* 0))))
                               (ASSQ (CADAR P) ALIST))
                             (LOSE))))))))
             (MATCH1 PATTERN
                     EXPRESSION
                     NIL
                     (LAMBDA () NIL)))))
</code></pre>

            <h3>A Useless Multiprocessing Example</h3>
            <p>
            One thing we might want to use multiprocessing for is to try two
            things in parallel, and terminate as soon as one succeeds. We can do
            this with the following function.
            </p>

            <pre><code>
    (DEFINE TRY!TWO!THINGS!IN!PARALLEL
       (LAMBDA (F1 F2)
          (CATCH C
             ((LAMBDA (P1 P2)
                 ((LAMBDA (F1 F2)
                      (EVALUATE!UNINTERRUPTIBLY
                       (BLOCK (ASET 'P1 (CREATE!PROCESS '(F1)))
                              (ASET 'P2 (CREATE!PROCESS '(F2)))
                              (START!PROCESS P1)
                              (START!PROCESS P2)
                              (STOP!PROCESS **PROCESS**))))
                  (LAMBDA ()
                     ((LAMBDA (VALUE)
                         (EVALUATE!UNINTERRUPTIBLY
                          (BLOCK (STOP!PROCESS P2) (C VALUE))))
                      (F1)))
                  (LAMBDA ()
                     ((LAMBDA (VALUE)
                         (EVALUATE!UNINTERRUPTIBLY
                          (BLOCK (STOP!PROCESS P1) (C VALUE))))
                      (F2)))))
          NIL NIL))))
</code></pre>

            <p>
            <code>TRY!TWO!THINGS!IN!PARALLEL</code> takes two functions of no
            arguments (in order to pass an unevaluated expression and its
            environment in for later use, so as to avoid variable conflicts). It
            creates two processes to run them, and returns the value of
            whichever completes first.
            </p>

            <p>
            As an example of how to misuse
            <code>TRY!TWO!THINGS!IN!PARALLEL</code>, here is a function which
            determines the sign of an integer using only <code>ADD1</code>,
            <code>SUB1</code>, and <code>EQUAL</code>.
            </p>

            <pre><code>
    (DEFINE SIGN
        (LAMBDA (N)
            (IF (EQUAL N 0) 'ZERO
                (TRY!TWO!THINGS!IN!PARALLEL
                    (LAMBDA ()
                        (DO ((I 0 (ADD1 I)))
                            ((EQUAL I N) 'POSITIVE)))
                    (LAMBDA ()
                        (DO ((I 0 (SUB1 I)))
                            ((EQUAL I N) 'NEGATIVE)))))))
</code></pre>
        </div>

        <div>
            <h2>Section 3: Substitution Semantics and Programming Styles</h2>

            <p>
            In the previous section we showed several different SCHEME programs
            for computing the factorial function. How are they different? We
            intuitively distinguish recursive from iterative programs, for
            example, by noting that recursive programs "call themselves" but in
            the last section we claimed to do iteration with a seemingly
            recursive program. Experienced programmers "know" that recursion
            uses up "stack" so a program implemented recursively will run out of
            stack on a sufficiently large problem. Can we make these ideas more
            precise? One traditional approach is to model the computation with
            lambda calculus.
            </p>

            <h3>Reviewing the Lambda Calculus</h3>
            <p>
            Traditionally language constructs are broken up into two distinct
            classes: imperative constructs and those with side-effects &mdash;
            such as assignment and go-to; and applicative construct &mdash;
            those executed for value &mdash; such as arithmetic expressions. In
            addition, compiled languages often require a third class,
            declarative constructs, but these are provided primarily to guide
            the compilation process and do not directly affect the semantics of
            execution, and so will not concern use here.
            </p>

            <p>
            Lambda calculus is a model for the applicative component of
            programming languages. It models all non-imperative constructs as
            applications of functions and specifies the semantics of such
            expressions by a set of axioms of rewrite rules. One axiom states
            that a combination, i.e. an expression formed by a function with the
            appropriate arguments substituted for the free occurences of the
            formal parameters of the functions in its body:
            </p>

            <pre><code>
    ((LAMBDA &lt;vars&gt; &lt;body&gt;) &lt;args&gt;) = Subst[&lt;args&gt; &lt;vars&gt; &lt;body&gt;]
</code></pre>

            <p>
            Another axiom requires that the meaning of an expression be
            independent of the names of the formal parameters bound in the
            expression:
            </p>

            <pre><code>
    (LAMBDA &lt;vars&gt; &lt;body&gt;)
            = (LAMBDA &lt;newvars&gt; Subst[&lt;newvars&gt; &lt;vars&gt; &lt;body&gt;])
    provided that none of &lt;newvars&gt; appears free in &lt;body&gt;.
</code></pre>

            <p>
            These constraints force Subst to be defined in such a way that an
            important kind of <em>referential transparency</em> is obtained.
            Besides these "structural" axioms, other are provided which specify
            the result of certain primitive functions applied to specific
            arguments. We shall not be concerned with these problems here
            &mdash; we will assume a small reasonable set of primitive
            functions.
            </p>

	    <h3>Recursive Programs</h3>

	    <p>
            Now let's see how lambda calculus may be used (informally) to model
            a computation. Consider the standard definition of the factorial
            function:
	    </p>

            <pre><code>
    (DEFINE FACT
       (LAMBDA (N) (IF (= N 0) 1
                       (* N (FACT (- N 1))))))
</code></pre>

            <p>
            We are being <em>very</em> informal &mdash; lambda calculus as
            presented by [Church] does not include such constructs as
            <code>DEFINE</code>, <code>IF</code>, or <code>=</code>,
            <code>*</code>, or even <code>1</code>! The "usual" lambda calculus
            construct for defining recursive functions is a rather obscure
            object called the "fixed-point" operator. We have been lax to avoid
            the hassle of "rigor mortis" in this tutorial paper. Similarly,
            <code>IF</code> is the SCHEME conditional construct we will use for
            convenience, it reduces to its second or third argument depending on
            whether the first reduces to <code>TRUE</code> or
            <code>FALSE</code>. The objects <code>*</code>, <code>=</code>,
            <code>0</code>, <code>1</code>, etc. may be thought of as
            abbreviations for complex lambda expressions (such as Church
            numerals) whose details we are not interested in. On the other hand,
            we may think of them as primitive expressions, defined by additional
            axioms; this viewpoint leads to practical interpreter
            implementations.
            </p>

            <p>
            Now let's reduce the expression <code>(FACT 3)</code>. We will
            perform the expression reductions, except for the <code>IF</code>
            primitive, in Applicative Order (call by value), though this is not
            necessary, as we will discuss later. We display a "trace" of the
            substitutions:
            </p>

            <pre><code>
    =&gt;   (FACT 3)
    =&gt;   (IF (= 3 0) 1 (* 3 (FACT (- 3 1))))
    =&gt;   (* 3 (FACT (- 3 1)))
    =&gt;   (* 3 (FACT 2))
    =&gt;   (* 3 (IF (= 2 0) 1 (* 2 (FACT (- 2 1)))))
    =&gt;   (* 3 (* 2 (FACT (- 2 1))))
    =&gt;   (* 3 (* 2 (FACT 1)))
    =&gt;   (* 3 (* 2 (IF (= 1 0) 1 (* 1 (FACT (- 1 1))))))
    =&gt;   (* 3 (* 2 (* 1 (FACT (- 1 1)))))
    =&gt;   (* 3 (* 2 (* 1 (FACT 0))))
    =&gt;   (* 3 (* 2 (* 1 (IF (= 0 0) 1 (* 0 (FACT (- 0 1)))))))
    =&gt;   (* 3 (* 2 (* 1 1)))
    =&gt;   (* 3 (* 2 1))
    =&gt;   (* 3 2)
    =&gt;   6
</code></pre>

            <p>
            You will note that we have calculated <code>(FACT 3)</code> by a
            process wherein <em>each expression is replaced</em> by an
            expression which is provably equivalent to it via an axiom of which
            is produced by application of a primitive function.
            </p>

            <h3>Now, What About Iteration?</h3>
            <p>
            Consider the "iterative" definition of <code>FACT</code>. Altough it
            appears to be recursive, since it "calls itself", we will see that
            it captures the essence of our notion of iteration.
            </p>

            <pre><code>
    (DEFINE FACT
       (LAMBDA (N)
           (LABELS ((FACT1
                     (LAMBDA (M ANS)
                         (IF (= M 0) ANS
                             (FACT1 (- M 1) (* M ANS))))))
                (FACT1 N))))
</code></pre>

            <p>
            Let us now compute <code>(FACT 3)</code>.
            </p>

            <pre><code>
    =&gt;   (FACT 3)
    =&gt;   (FACT 1 3 1)
    =&gt;   (IF (= 3 0) 1
             (FACT1 (- 3 1) (* 3 1)))
    =&gt;   (FACT1 (- 3 1) (* 3 1))
    =&gt;   (FACT1 2 (* 3 1))
    =&gt;   (FACT1 2 3)
    =&gt;   (IF (= 2 0) 3
             (FACT1 (- 2 1) (* 2 3)))
    =&gt;   (FACT1 (- 2 1) (* 2 3))
    =&gt;   (FACT1 1 (* 2 3))
    =&gt;   (FACT1 1 6)
    =&gt;   (IF (= 1 0) 6
             (FACT1 (- 1 1) (* 1 6)))
    =&gt;   (FACT1 (- 1 1) (* 1 6))
    =&gt;   (FACT1 0 (* 1 6))
    =&gt;   (FACT1 0 6)
    =&gt;   (IF (= 0 0) 6
             (FACT1 (- 0 1) (* 0 6)))
    =&gt;   6
</code></pre>

            <p>
            Notice that the expression involved have a fixed maximum size
            independent of the argument to <code>FACT</code>! In fact, as Marvin
            Minsky pointed out, successive reductions produce a cycle of
            expressions which are identical except for the numerical quantities
            involved. Looking back, we may note by the way of comparison that
            the recursive version caused creation of expressions proportional in
            size to the argument. This is why we think that this version of
            <code>FACT</code> is iterative rather than recursive. At each stage
            of the iterative version the "state" of the computation is
            summarized in two variables, the counter and the answer accumulator,
            while at each stage of the recursive version the "state" contains a
            chain of pieces each of which contains a component of the state. In
            the recursive version of <code>FACT</code>, for example, the state
            contains the sequence of multiplications to be performed upon return
            from the bottom. It is true that the iterative factorial also can
            produce expressions of arbitrary size, since the number of bits
            needed to express factorial of n grows with n; but this is a
            property of the numbers calculated by the function which is
            implemented in iterative style, and not of the iterative control
            structure itself. A recursive control structure <em>inherently</em>
            creates expressions of unbounded size as a function of the recursion
            depth, while an iterative control structure produces a cycle of
            equivalent expressions, and so the expressions are of approximately
            the same size no matter how many iteration steps are taken. This is
            the essence of the difference between notions of iteration and
            recursion. Hewitt [MAC, p. 234] made similar observation in
            passing, expressing the difference in term of storage used in
            program execution rather than in terms of intermediate expressions
            produced by substitution semantics.
            </p>

            <h3>Continuation Passing Recursion</h3>
            <p>
            Remember the other way to compute factorials?
            </p>

            <pre><code>
    (DEFINE FACT
       (LAMBDA (N C)
          (IF (= N 0) (C 1)
              (FACT (- N 1)
                    (LAMBDA (A) (C (* N A)))))))
</code></pre>

            <p>
            This looks iterative on the surface! but in fact it is recursive.
            Let's compute <code>(FACT 3 ANSWER)</code>, where
            <code>ANSWER</code> is a continuation which is to receive the result
            of <code>FACT</code> applied to <code>3</code>; that is, that last
            thing <code>FACT</code> should do is apply the continuation
            <code>ANSWER</code> to its result.
            </p>

            <pre><code>
    =&gt;   (FACT 3 ANSWER)
    =&gt;   (IF (= 3 0) (ANSWER 1)
                 (FACT (- 3 1) (LAMBDA (A) (ANSWER (* 3 A)))))
    =&gt;   (FACT (- 3 1) (LAMBDA (A) (ANSWER (* 3 A))))
    =&gt;   (FACT 2 (LAMBDA (A) (ANSWER (* 3 A))))
    =&gt;   (IF (= 2 0) ((LAMBDA (A) (ANSWER (* 3 A))) 1)
                 (FACT (- 2 1)
                       (LAMBDA (A)
                               ((LAMBDA (A) (ANSWER (* 3 A)))
                                (* 2 A)))))
    =&gt;   (FACT (- 2 1)
                   (LAMBDA (A)
                           ((LAMBDA (A) (ANSWER (* 3 A)))
                            (* 2 A))))
    =&gt;   (FACT 1
                   (LAMBDA (A)
                           ((LAMBDA (A) (ANSWER (* 3 A)))
                            (* 2 A))))
    =&gt;   (IF (= 1 0)
                 ((LAMBDA (A) 
                          ((LAMBDA (A) (ANSWER (* 3 A)))
                           (* 2 A)))
                  1)
                 (FACT (- 1 1)
                       (LAMBDA (A)
                               ((LAMBDA (A)
                                        ((LAMBDA (A)
                                                 (ANSWER (* 3 A)))
                                         (* 2 A)))
                                (* 1 A)))))
    =&gt;   (FACT (- 1 1)
                   (LAMBDA (A)
                           ((LAMBDA (A)
                                    ((LAMBDA (A)
                                             (ANSWER (* 3 A)))
                                     (* 2 A)))
                             (* 1 A))))
    =&gt;   (FACT 0
                  (LAMBDA (A)
                          ((LAMBDA (A)
                                   ((LAMBDA (A)
                                            (ANSWER (* 3 A)))
                                    (* 2 A)))
                           (* 1 A))))
    =&gt;   (IF (= 0 0)
                 ((LAMBDA (A)
                          ((LAMBDA (A)
                                   ((LAMBDA (A)
                                            (ANSWER (* 3 A)))A
                                    (* 2 A)))
                           (* 1 A)))
                   1)
                  (FACT (- 0 1)
                        (LAMBDA (A)
                                ((LAMBDA (A)
                                         ((LAMBDA (A)
                                                  ((LAMBDA (A)
                                                           (ANSWER (* 3 A)))
                                                   (* 2 A)))
                                          (* 1 A)))
                                 (* 0 A)))))
    =&gt;   ((LAMBDA (A)
              ((LAMBDA (A)
                       ((LAMBDA (A)
                                (ANSWER (* 3 A)))
                        (* 2 A)))
               (* 1 A)))
             1)
    =&gt;   ((LAMBDA (A)
                      ((LAMBDA (A)
                               (ANSWER (* 3 A)))
                       (* 2 A)))
             (* 1 1))
    =&gt;   ((LAMBDA (A)
                      ((LAMBDA (A)
                               (ANSWER (* 3 A)))
                       (* 2 A)))
             1)
    =&gt;   ((LAMBDA (A)
                     (ANSWER (* 3 A)))
             (* 2 1))
    =&gt;   ((LAMBDA (A)
                     (ANSWER (* 3 A)))
             2)
    =&gt;   (ANSWER (* 3 2))
    =&gt;   (ANSWER 6)      WHEW!
</code></pre>

            <p>
            Note that we have computed the factorial of 3 (and are about to give
            this result to the continuation), but in the process no combination
            with <code>FACT</code> in the first position has ever been reduced
            except as the outermost expression. If we think of the computation
            in terms of evaluation rather than substitution, this means that
            <em>we never returned a value from any application of the function
            <code>FACT</code></em>! It is always possible, if we are willing to
            specify explicitly what to do with the answer, to perform any
            calculation in this way: rather than reducing to its value (cf.
            [Fisher]). That is, in this continuation-passing programming style,
            <em>a function always "returns" its result by "sending" it to
            another function</em>. This is the key idea.
            </p>
            <p>
            We also note that by our previous observation, this program is
            essentially recursive in that the expressions produced as
            intermediate results of the substitution semantics grow to a size
            proportional to the depth. In fact, the same information is being
            stored in the nested continuations produced by this program as in
            the nested products produced by the traditional recursion &mdash;
            what to do with the result.
            </p>
            <p>
            One might object that this <code>FACT</code> is not the same kind of
            object as the previous definition, since we can't use it as a
            function in the same manner. Note however, that if we supply the
            continuation <code>(LAMBDA (X) X)</code>, the resulting combination
            <code>(FACT 3 (LAMBDA (X) X))</code> will reduce to <code>6</code>,
            just as with traditional recursion.
            </p>
            <p>
            One might also object that we are using function values &mdash; the
            primitives <code>=</code>, <code>-</code> and <code>*</code> are
            functions which return values, for example. But this is just a
            property of the primitives; consider a new set of primitives
            <code>==</code>, <code>--</code> and <code>**</code> which accept
            continuations (indeed, let <code>==</code> take two continuations:
            if the predicate is <code>TRUE</code> call the first, otherwise call
            the second). We can define <code>FACT</code> as follows:
            </p>
            <pre><code>
    (DEFINE FACT
       (LAMBDA (N C)
           (== N 0
               (LAMBDA () (C 1))
               (LAMBDA ()
                   (-- N 1
                       (LAMBDA (M)
                           (FACT M (LAMBDA (A) (** A N C)))))))))
</code></pre>

            <p>
            We can see here that no functional application returns value in a
            computation of factorial in this situation. We believe that
            functional usage, where applicable (pun intended), is more
            perspisuous than continuation-passing. We shall therefore use
            functional primitives such as <code>*</code> rather than
            <code>**</code> whereever possible, keeping in mind the we could use
            <code>**</code> instead if we wished.
            </p>

        </div>

        <div>
            <h2>Section 4: Some Implementation Issues</h2>

            <p>
            The key problem is <em>efficiency</em>. Although it is easy to build
            an inefficient interpreter which straightforwardly performs
            expression substitutions; such an interpreter performs much
            unnecessary copying of intermediate expressions. The standard
            solution to this problem is to use an auxiliary structure, called the
            <em>environment</em>, which represents a set of
            <em>virtual substitutions</em>. Thus, when evaluating an expression
            of the form
            </p>

            <pre><code>
    ((LAMBDA &lt;vars&gt; &lt;body&gt;) &lt;args&gt;) in environment E
            </code></pre>

            <p>
            instead of reducing it by performing
            </p>

            <pre><code>
    Subst[&lt;args&gt; &lt;vars&gt; &lt;body&gt;]
            </code></pre>

            <p>
            we reduce to
            </p>

            <pre><code>
    &lt;body&gt; in environment E'=Pairlis[&lt;vars&gt; &lt;args&gt;* E]
            </pre></code>

            <p>
            where <em>pairlis</em> creates a new environment E' in which the &lt;vars&gt;
            are logically paired with (i.e. "bound to") the corresponding &lt;args&gt;*
            (the precise meaning of &lt;args&gt;* will be explained presently), and in
            which any variables not in &lt;vars&gt; are bound as they were in E.
            </p>

            <p>
            When using environments, it is necessary to keep them straight. For
            example, the following expression should manage to evaluate to 7:
            </p>

            <pre><code>
    (((LAMBDA (X) (LAMBDA (Y) (+ X Y))) 3) 4)
            </code></pre>

            <p>
            A substitution interpreter would cause the free occurence of <code>x</code>
            in the inner lambda expression to be replaced by 3 before applying that
            lambda expression to 4. An interpreter which uses environments must arrange
            for the expression <code>(+ x y)</code> to be evaluated in an environment
            such that <code>x</code> is bound to 3 and <code>y</code> is bound to 4.
            This implies that when the inner lambda expression is applied to 4, there
            must be associated with it an environment in which <code>x</code> is bound
            to 3. In order to solve this problem we introduce the notion of a
            <em>closure</em> [McCarthy][Moses] which is a data structure containing a
            lambda expression, and an environment to be used when that lambda expression
            is applied to arguments. We will notate a closure using the <em>beta</em>
            construct (our own notation, but isomorphic to the LISP <em>funarg</em>
            construct) as follows:
            </p>
        </div>

    </body>
</html>
