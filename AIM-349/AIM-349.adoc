= Scheme: An interpreter for extended lambda calculus
AI Memo No. 349, December 1975
Gerald Jay Sussman and Guy Lewis Steele Jr.

== Abstract

Inspired by ACTORS [Greif and Hewitt] [Smith and Hewitt], we have implemented an interpreter for a LISP-like language, SCHEME, based on the lambda calculus [Church], but extended for side effects, multiprocessing, and process synchronization.
The purpose of this implementation is tutorial.
We wish to:

. alleviate the confusion caused by Micro-PLANNER, CONNIVER, etc. by clarifying the embedding of non-recursive control structures in a recursive host language like LISP.
. explain how to use these control structures, independent of such issues as pattern matching and data base manipulation.
. have a simple concrete experimental domain for certain issues of programming semantics and style.

This paper is organized into sections.
The first section is a short "reference manual" containing specifications for all the unusual features of SCHEME.
Next, we present a sequence of programming examples which illustrate various programming styles, and how to use them.
This will raise certain issues of semantics which we will try to clarify with lambda calculus in the third section.
In the fourth section we will give a general discussion of the issues facing an implementor of an interpreter for a language based on lambda calculus.
Finally, we present a completely annotated interpreter for SCHEME, written in MacLISP [Moon], to acquaint programmers with the tricks of the trade of implementing non-recursive control structures in a recursive language like LISP.

This report describes research done at the Artificial Intelligence Laboratory of the Massachusetts Institute of Technology.
Support for the laboratory's artificial intelligence research is provided in part by the Advanced Research Projects Agency of the Department of Defense under Office of Naval Research contract N00014-75-C-0643.

== Section 1: The SCHEME Reference Manual

SCHEME is essentially a full-funarg LISP.
`+LAMBDA+` expressions need not be ``QUOTE``d, ``FUNCTION``ed, or ``*FUNCTION``ed when passed as arguments or returned as values; they will evaluate to closures of themselves.

All LISP functions (i.e., ``EXPR``s, ``SUBR``s, and ``LSUBR``s, but _not_ ``FEXPR``s, ``FSUBR``s, or ``MACRO``s) are primitive operators in SCHEME, and have the same meaning as they have in LISP.
Like `+LAMBDA+` expressions, primitive operators and numbers are self-evaluating (they evaluate to trivial closures of themselves).

There are a number of special primitives known as `+AINT+` s which are to SCHEME as `+FSUBR+` s are to LISP. We will enumerate them here.

=== `+IF+`

This is the primitive conditional operator.
It takes three arguments.
If the first evaluates to non-`+NIL+`, it evaluates the second expression, and otherwise the third.

=== `+QUOTE+`

As in LISP, this quotes the argument form so that it will be passed verbatim as data.
The abbreviation "`+'FOO`+" may be used instead of "`+(QUOTE FOO)+`".

=== `+DEFINE+`

This is analogous to the MacLISP `+DEFUN+` primitive (but note that the `+LAMBDA+` must appear explicitly!).
It is used for defining a function in the "global environment" permanently, as opposed to `+LABELS+` (see below), which is used for temporary definitions in a local environment.
`+DEFINE+` takes a name and a lambda expression; it closes the lambda expression in the global environment and stores the closure in the LISP value cell of the name (which is a LISP atom).

=== `+LABELS+`

We have decided not to use the traditional `+LABEL+` primitive in this interpreter because it is difficult to define several mutually recursive functions using only `+LABEL+`.
The solution, which Hewitt [Smith and Hewitt] also uses, is to adopt an ALGOLesque block syntax:

[source]
----
(LABELS <function definition list> <expression>)
----

This has the effect of evaluating the expression in an environment where all the functions are defined as specified by the definition list.
Furthermore, the functions are themselves closed in that environment, and not in the outer environment; this allows the functions to call themselves _and each other_ recursively.
For example, consider a function which counts all the atoms in a list structure recursively to all levels, but which doesn't count the `+NIL+` s which terminate the lists (but ``NIL``s in the `+CAR+` of some list count).
In order to perform this we use two mutually recursive functions, one to count the car and one to count the cdr, as follows:

[,scheme]
----
include::1.scm[]
----

=== `+ASET+`

This is the side effect primitive.
It is analogous to the LISP function `+SET+`.
For example, to define a _cell_ [Smith and Hewitt], we may use `+ASET+` as follows:

[,scheme]
----
include::2.scm[]
----

Those of you who may complain about the lack of `+ASETQ+` are invited to write `+(ASET' foo bar)+` instead of `+(ASET 'foo bar)+`.

=== `+EVALUATE+`

This is similar to the LISP function `+EVAL+`.
It evaluates its argument, and then evaluates the resulting s-expression as SCHEME code.

=== `+CATCH+`

This is the "escape operator" which gives the user a handle on the control structure of the interpreter. The expression:

[source]
----
(CATCH <identifier> <expression>)
----

evaluates `+<expression>+` in an environment where `+<identifier>+` is bound to a continuation which is "just about to return from the `+CATCH+`"; that is, if the continuation is called as a function of one argument, then control proceeds as if the `+CATCH+` expression had returned with the supplied (evaluated) argument as its value.
For example, consider the following obscure definition of `+SQRT+` (Sussman's favorite style/Steele's least favorite):

[,scheme]
----
include::3.scm[]
----

Anyone who doesn't understand how this manages to work probably should not attempt to use `+CATCH+`.

As another example, we can define a `+THROW+` function, which may then be used with `+CATCH+` much as they are in LISP:

[,scheme]
----
include::4.scm[]
----

=== `+CREATE!PROCESS+`

This is the process generator for multiprocessing.
It takes one argument, an expression to be evaluated in the current environment as a separate parallel process.
If the expression ever returns a value, the process automatically terminates.
The value of `+CREATE!PROCESS+` is a process id for the newly generated process.
Note that the newly created process will not actually run until it is explicitly started.

=== `+START!PROCESS+`

This takes one argument, a process id, and starts up that process.
It then runs.

=== `+STOP!PROCESS+`

This also takes a process id, but stops the process.
The stopped process may be continued from where it was stopped by using `+START!PROCESS+` again on it.
The magic global variable `+**PROCESS**+` always contains the process id of the currently running process; thus a process can stop itself by doing `+(STOP!PROCESS **PROCESS**)+`.
A stopped process is garbage collected if no live process has a pointer to its process id.

=== `+EVALUATE!UNINTERRUPTIBLY+`

This is the synchronization primitive.
It evaluates an expression uninterruptibly; i.e. no other process may run until the expression has returned a value.
Note that if a funarg is returned from the scope of an `+EVALUATE!UNINTERRUPTIBLY+`, then that funarg will be uninterruptible when it is applied; that is, the uninterruptibility property follow the rules of variable scoping.
For example, consider the following function:

[,scheme]
----
include::5.scm[]
----

This returns a pair of functions which are V and P operations on a newly created semaphore.
The argument to `+SEMGEN+` is the initial value for the semaphore.
Note that P busy-waits by iterating if necessary; because `+EVALUATE!UNINTERRUPTIBLY+` uses variable-scoping rules, other processes have a chance to get in at the beginning of each iteration.
This busy-wait can be made much more efficient by replacing the expression `+(P)+` in the definition of `+P+` with

[,scheme]
----
include::6.scm[]
----

Let's see you figure this one out! Note that a `+STOP!PROCESS+` within an `+EVALUATE!UNINTERRUPTIBLY+` forces the process to be swapped out even if it is the current one, and so other processes get to run; but as soon as it gets swapped in again, others are locked out as before.

Besides the `+AINT+` s, SCHEME has class of primitives known as `+AMACRO+` s.
These are similar to MacLISP `+MACRO+` s, in that they are expanded into equivalent code before being executed.
Some `+AMACRO+` s supplied with the SCHEME interpreter:

=== `+COND+`

This is like the MacLISP `+COND+` statement, except that singleton clauses (where the result of the predicate is the returned value) are not allowed.

=== `+AND+`, `+OR+`

These are also as in MacLISP.

=== `+BLOCK+`

This is like the MacLISP `+PROGN+`, but arranges to evaluate its last argument without an extra net control frame (explained later), so that the last argument may involved in an iteration.
Note that in SCHEME, unlike MacLISP, the body of a `+LAMBDA+` expression is _not_ an implicit `+PROGN+`.

=== `+DO+`

This is like that MacLISP "new-style" `+DO+`; old-style `+DO+` is not supported.

=== `+AMAPCAR+`, `+AMAPLIST+`

These are like `+MAPCAR+` and `+MAPLIST+`, but they expect a SCHEME lambda closure for the first argument.

To use SCHEME, simply incant at DDT (MIT-AI):

[,scheme]
----
include::7.scm[]
----

which will load up the current version of SCHEME, which will announce itself and give a prompt.
If you want to escape to LISP, merely hit `+^G+`.
To restart SCHEME, type `+(SCHEME)+`.
Sometimes one does need to use a LISP `+FSUBR+` such as `+UREAD+`; this may be accomplished by typing, for example,

[,scheme]
----
include::8.scm[]
----

After doing this, typing `+^Q+` will, of course, cause SCHEME to read from the file.

This concludes the SCHEME Reference Manual.

== Section 2: Some SCHEME Programming Examples

=== Traditional Recursion

Here is the good old familiar recursive definition of factorial, written in SCHEME.

[,scheme]
----
include::9.scm[]
----

=== What About Iteration?

There are many other ways to compute factorial.
One important way is through the use of _iteration_.
Consider the following definition of `+FACT+`.
Although it appears to be recursive, since it "calls itself", it captures the essence of our intuitive notion of iteration, because execution of this program will not produce internal structures (e.g. stacks or variable bindings) which increase in size with the number of iteration steps.
This surprising fact will be explained in two ways.

. We will consider programming styles in terms of substitution semantics of the lambda calculus (Section 3).
. We will show how the SCHEME interpreter is implemented (Sections 4,5).

[,scheme]
----
include::10.scm[]
----


A common iterative construct is the `+DO+` loop.
The most general form we have seen in any programming language is the MacLISP `+DO+` [Moon].
It permits the simultaneous initialization of any number of control variables and the simultaneous stepping of these variables by arbitrary functions at each iteration step.
The loop is terminated by an arbitrary predicate, and an arbitrary value may be returned.
The `+DO+` loop may have a body, a series of expressions executed for effect on each iteration.

The general form of a MacLISP `+DO+` is:

[source]
----
(DO ((<var1>  <init1>  <step1>)
     (<var2>  <init2>  <step2>)
     . . .
     (<varn>  <initn>  <stepn>))
    (<pred>  <value>)
    <body>)
----

The semantics of this are that the variables are bound and initialized to the values of the <initi> expressions, which must all be evaluated in the environment outside the `+DO+`; then the predicate <pred> is evaluated in the new environment, and if `+TRUE+`, the <value> is evaluated and returned.
Otherwise the body is evaluated, then each of the steppers <stepi> is evaluated in the current environment, all the variables made to have the results as their values, and the predicate evaluated again, and so on.

For example, the following MacLISP function:

[,scheme]
----
include::11.scm[]
----

computes the reverse of a list.
In SCHEME, we could write the same function, in the same iterative style, as follows:

[,scheme]
----
include::12.scm[]
----

From this we can infer a general way to express iterations in SCHEME in a manner isomorphic to the MacLISP `+DO+`:

[source]
----
(LABELS ((DOLOOP
         (LAMBDA (<dummy> <var1> <var2> ...  <varn>)
             (IF <pred> <value>
                 (DOLOOP <body> <step1> <step2> ... <stepn>)))))
        (DOLOOP NIL <init1> <init2> ... <initn>))
----

This is in fact what the supplied `+DO+` `+AMACRO+` expands into.
Note that there are no side effects in the steppings of the iteration variables.

=== Another Way To Do Recursion

Now consider the following alternative definition of `+FACT+`.
It has an extra argument, the _continuation_ [Reynolds], which is a function to call with the answer, when we have it, rather than return a value; that is, rather than ultimately reducing to the desired value, it reduces to a combination which is the application of the continuation to the desired value.










